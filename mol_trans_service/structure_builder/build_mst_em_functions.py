"""
Utilities to automate MST L2 Extended Molecule construction.

Exposes:
- align_molecule_to_z_axis(molecule_xyz, left_anchor_idx, right_anchor_idx)
- assemble_em(aligned_mol_path, template_path, bond_L, bond_R, left_anchor_idx, right_anchor_idx)
- validate_em_structure(em_file_path, template_path)
"""

from __future__ import annotations

import math
from pathlib import Path
from typing import List, Sequence, Tuple

Atom = dict[str, Sequence[float]]


def _read_xyz(path: str | Path) -> Tuple[List[Atom], str]:
    path = Path(path)
    with path.open("r", encoding="utf-8") as handle:
        try:
            atom_count = int(handle.readline().strip())
        except ValueError as exc:
            raise ValueError(f"First line of {path} must be an integer atom count") from exc
        comment = handle.readline().rstrip("\n")
        atoms: List[Atom] = []
        for line in handle:
            parts = line.split()
            if len(parts) < 4:
                continue
            element = parts[0]
            try:
                coords = [float(parts[1]), float(parts[2]), float(parts[3])]
            except ValueError as exc:
                raise ValueError(f"Could not parse coordinates in {path}") from exc
            atoms.append({"element": element, "coords": coords})
        if len(atoms) != atom_count:
            raise ValueError(f"{path} reports {atom_count} atoms but {len(atoms)} coordinates were read")
    return atoms, comment


def _write_xyz(path: str | Path, atoms: Sequence[Atom], comment: str = "") -> None:
    path = Path(path)
    lines = [str(len(atoms)), comment or "Generated by MST EM builder"]
    for atom in atoms:
        x, y, z = atom["coords"]
        lines.append(f"{atom['element']:2s} {x:15.8f} {y:15.8f} {z:15.8f}")
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def _dot(a: Sequence[float], b: Sequence[float]) -> float:
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]


def _cross(a: Sequence[float], b: Sequence[float]) -> List[float]:
    return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0],
    ]


def _norm(vec: Sequence[float]) -> float:
    return math.sqrt(_dot(vec, vec))


def _normalize(vec: Sequence[float]) -> List[float]:
    length = _norm(vec)
    if length == 0:
        raise ValueError("Cannot normalize a zero-length vector")
    return [component / length for component in vec]


def _matrix_vector_mul(matrix: Sequence[Sequence[float]], vec: Sequence[float]) -> List[float]:
    return [
        matrix[0][0] * vec[0] + matrix[0][1] * vec[1] + matrix[0][2] * vec[2],
        matrix[1][0] * vec[0] + matrix[1][1] * vec[1] + matrix[1][2] * vec[2],
        matrix[2][0] * vec[0] + matrix[2][1] * vec[1] + matrix[2][2] * vec[2],
    ]


def _matrix_multiply(a: Sequence[Sequence[float]], b: Sequence[Sequence[float]]) -> List[List[float]]:
    product: List[List[float]] = []
    for row_idx in range(3):
        row: List[float] = []
        for col_idx in range(3):
            value = (
                a[row_idx][0] * b[0][col_idx]
                + a[row_idx][1] * b[1][col_idx]
                + a[row_idx][2] * b[2][col_idx]
            )
            row.append(value)
        product.append(row)
    return product


def _rotation_matrix_axis_angle(axis: Sequence[float], angle: float) -> List[List[float]]:
    axis_normalized = _normalize(axis)
    x, y, z = axis_normalized
    cos_theta = math.cos(angle)
    sin_theta = math.sin(angle)
    one_minus_cos = 1.0 - cos_theta
    return [
        [
            cos_theta + x * x * one_minus_cos,
            x * y * one_minus_cos - z * sin_theta,
            x * z * one_minus_cos + y * sin_theta,
        ],
        [
            y * x * one_minus_cos + z * sin_theta,
            cos_theta + y * y * one_minus_cos,
            y * z * one_minus_cos - x * sin_theta,
        ],
        [
            z * x * one_minus_cos - y * sin_theta,
            z * y * one_minus_cos + x * sin_theta,
            cos_theta + z * z * one_minus_cos,
        ],
    ]


def _rotation_matrix_from_vectors(v_from: Sequence[float], v_to: Sequence[float]) -> List[List[float]]:
    v1 = _normalize(v_from)
    v2 = _normalize(v_to)
    cross_prod = _cross(v1, v2)
    dot_prod = _dot(v1, v2)
    cross_norm = _norm(cross_prod)
    if cross_norm < 1e-12:
        if dot_prod > 0:
            return [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
        # 180 degree rotation about an arbitrary axis perpendicular to v1
        axis_guess = [1.0, 0.0, 0.0] if abs(v1[0]) < 0.9 else [0.0, 1.0, 0.0]
        return _rotation_matrix_axis_angle(axis_guess, math.pi)
    skew = [
        [0.0, -cross_prod[2], cross_prod[1]],
        [cross_prod[2], 0.0, -cross_prod[0]],
        [-cross_prod[1], cross_prod[0], 0.0],
    ]
    skew_sq = _matrix_multiply(skew, skew)
    scale = (1.0 - dot_prod) / (cross_norm ** 2)
    rotation = []
    for row_idx in range(3):
        row = []
        for col_idx in range(3):
            value = (
                (1.0 if row_idx == col_idx else 0.0)
                + skew[row_idx][col_idx]
                + skew_sq[row_idx][col_idx] * scale
            )
            row.append(value)
        rotation.append(row)
    return rotation


def _extract_au_clusters(template_atoms: Sequence[Atom]) -> Tuple[List[Atom], List[Atom]]:
    left_cluster: List[Atom] = []
    idx = 0
    while idx < len(template_atoms) and template_atoms[idx]["element"].lower() == "au":
        left_cluster.append(template_atoms[idx])
        idx += 1
    right_cluster: List[Atom] = []
    idx_right = len(template_atoms) - 1
    while idx_right >= 0 and template_atoms[idx_right]["element"].lower() == "au":
        right_cluster.append(template_atoms[idx_right])
        idx_right -= 1
    right_cluster.reverse()
    if not left_cluster or not right_cluster:
        raise ValueError("Template must contain Au clusters at both the top and bottom of the file")
    return left_cluster, right_cluster


def _translate_atom(atom: Atom, delta: Sequence[float]) -> Atom:
    return {
        "element": atom["element"],
        "coords": [
            atom["coords"][0] + delta[0],
            atom["coords"][1] + delta[1],
            atom["coords"][2] + delta[2],
        ],
    }


def _classify_template(left_cluster: Sequence[Atom], right_cluster: Sequence[Atom]) -> str:
    n_left = len(left_cluster)
    n_right = len(right_cluster)
    if n_left == 4 and n_right == 4:
        return "pyramid"
    if n_left == 3 and n_right == 3:
        return "trimer"
    raise ValueError(
        f"Unsupported template: expected 4/4 (pyramid) or 3/3 (trimer) Au atoms, got {n_left}/{n_right}"
    )


def _extract_trimer_anchor_positions(template_atoms: Sequence[Atom], n_left: int, n_right: int) -> Tuple[List[float], List[float]]:
    middle_atoms = template_atoms[n_left : len(template_atoms) - n_right]
    s_atoms = [atom for atom in middle_atoms if atom["element"].lower() == "s"]
    if len(s_atoms) < 2:
        raise ValueError("Trimer template must contain at least two S atoms to define anchor positions")
    # Use the smallest and largest Z to represent left/right anchors.
    s_atoms_sorted = sorted(s_atoms, key=lambda atom: atom["coords"][2])
    return s_atoms_sorted[0]["coords"], s_atoms_sorted[-1]["coords"]


def _translate_atoms(atoms: Sequence[Atom], delta: Sequence[float]) -> List[Atom]:
    return [_translate_atom(atom, delta) for atom in atoms]


def _assemble_pyramid_em(
    molecule_atoms: Sequence[Atom],
    left_cluster: Sequence[Atom],
    right_cluster: Sequence[Atom],
    bond_L: float,
    bond_R: float,
    left_anchor_idx: int,
    right_anchor_idx: int,
) -> Tuple[List[Atom], str]:
    left_apex_idx = max(range(len(left_cluster)), key=lambda idx: left_cluster[idx]["coords"][2])
    right_apex_idx = min(range(len(right_cluster)), key=lambda idx: right_cluster[idx]["coords"][2])
    left_apex = left_cluster[left_apex_idx]["coords"]
    right_apex = right_cluster[right_apex_idx]["coords"]
    left_cluster_recentered = _translate_atoms(left_cluster, [-left_apex[0], -left_apex[1], -left_apex[2]])
    right_cluster_recentered = _translate_atoms(right_cluster, [-right_apex[0], -right_apex[1], -right_apex[2]])
    left_anchor = molecule_atoms[left_anchor_idx]["coords"]
    right_anchor = molecule_atoms[right_anchor_idx]["coords"]
    if right_anchor[2] < left_anchor[2]:
        raise ValueError("Right anchor must have a larger Z value than the left anchor after alignment")
    shift_z = bond_L - left_anchor[2]
    shifted_molecule = _translate_atoms(molecule_atoms, [0.0, 0.0, shift_z])
    shifted_right_anchor = [
        right_anchor[0],
        right_anchor[1],
        right_anchor[2] + shift_z,
    ]
    left_cluster_positioned = left_cluster_recentered
    right_cluster_target = [
        shifted_right_anchor[0],
        shifted_right_anchor[1],
        shifted_right_anchor[2] + bond_R,
    ]
    right_cluster_positioned = _translate_atoms(right_cluster_recentered, right_cluster_target)
    comment = f"bond_L={bond_L:.3f} bond_R={bond_R:.3f}"
    em_atoms = list(left_cluster_positioned) + list(shifted_molecule) + list(right_cluster_positioned)
    return em_atoms, comment


def _assemble_trimer_em(
    molecule_atoms: Sequence[Atom],
    template_atoms: Sequence[Atom],
    left_cluster: Sequence[Atom],
    right_cluster: Sequence[Atom],
    left_anchor_idx: int,
    right_anchor_idx: int,
) -> Tuple[List[Atom], str]:
    n_left = len(left_cluster)
    n_right = len(right_cluster)
    template_left_anchor, template_right_anchor = _extract_trimer_anchor_positions(template_atoms, n_left, n_right)
    left_anchor_atom = molecule_atoms[left_anchor_idx]
    right_anchor_atom = molecule_atoms[right_anchor_idx]
    if left_anchor_atom["element"].lower() != "s" or right_anchor_atom["element"].lower() != "s":
        raise ValueError("Trimer template requires both anchors to be S atoms")
    left_anchor = left_anchor_atom["coords"]
    right_anchor = right_anchor_atom["coords"]
    if right_anchor[2] <= left_anchor[2]:
        raise ValueError("Right anchor must have a larger Z value than the left anchor after alignment")
    # Keep left cluster fixed; shift molecule so its left S sits on the template left hollow site.
    molecule_shift = [
        template_left_anchor[0] - left_anchor[0],
        template_left_anchor[1] - left_anchor[1],
        template_left_anchor[2] - left_anchor[2],
    ]
    shifted_molecule = _translate_atoms(molecule_atoms, molecule_shift)
    shifted_right_anchor = shifted_molecule[right_anchor_idx]["coords"]
    # Translate right cluster as a rigid body so its hollow site coincides with the shifted right S anchor.
    right_cluster_shift = [
        shifted_right_anchor[0] - template_right_anchor[0],
        shifted_right_anchor[1] - template_right_anchor[1],
        shifted_right_anchor[2] - template_right_anchor[2],
    ]
    right_cluster_positioned = _translate_atoms(right_cluster, right_cluster_shift)
    comment = "trimer hollow matching: left cluster fixed, molecule shifted, right cluster translated"
    em_atoms = list(left_cluster) + list(shifted_molecule) + list(right_cluster_positioned)
    return em_atoms, comment


def align_molecule_to_z_axis(molecule_xyz: str | Path, left_anchor_idx: int, right_anchor_idx: int) -> str:
    atoms, _ = _read_xyz(molecule_xyz)
    if not (0 <= left_anchor_idx < len(atoms)) or not (0 <= right_anchor_idx < len(atoms)):
        raise IndexError("Anchor indices must be within the molecule atom count")
    left_atom = atoms[left_anchor_idx]
    right_atom = atoms[right_anchor_idx]
    anchor_vector = [
        right_atom["coords"][0] - left_atom["coords"][0],
        right_atom["coords"][1] - left_atom["coords"][1],
        right_atom["coords"][2] - left_atom["coords"][2],
    ]
    if _norm(anchor_vector) == 0:
        raise ValueError("Anchor atoms cannot occupy the same position")
    rotation = _rotation_matrix_from_vectors(anchor_vector, [0.0, 0.0, 1.0])
    aligned_atoms: List[Atom] = []
    for atom in atoms:
        shifted = [
            atom["coords"][0] - left_atom["coords"][0],
            atom["coords"][1] - left_atom["coords"][1],
            atom["coords"][2] - left_atom["coords"][2],
        ]
        rotated = _matrix_vector_mul(rotation, shifted)
        aligned_atoms.append({"element": atom["element"], "coords": rotated})
    aligned_path = Path(molecule_xyz).with_name("temp_aligned.xyz")
    _write_xyz(
        aligned_path,
        aligned_atoms,
        comment=(
            f"Aligned to +Z using anchors {left_anchor_idx} (left) and "
            f"{right_anchor_idx} (right); left anchor at origin"
        ),
    )
    return str(aligned_path)


def assemble_em(
    aligned_mol_path: str | Path,
    template_path: str | Path,
    bond_L: float,
    bond_R: float,
    left_anchor_idx: int,
    right_anchor_idx: int,
) -> str:
    molecule_atoms, _ = _read_xyz(aligned_mol_path)
    template_atoms, _ = _read_xyz(template_path)
    if not (0 <= left_anchor_idx < len(molecule_atoms)) or not (0 <= right_anchor_idx < len(molecule_atoms)):
        raise IndexError("Anchor indices must be within the aligned molecule atom count")
    left_cluster, right_cluster = _extract_au_clusters(template_atoms)
    template_kind = _classify_template(left_cluster, right_cluster)
    if template_kind == "pyramid":
        em_atoms, detail = _assemble_pyramid_em(
            molecule_atoms,
            left_cluster,
            right_cluster,
            bond_L,
            bond_R,
            left_anchor_idx,
            right_anchor_idx,
        )
    else:
        em_atoms, detail = _assemble_trimer_em(
            molecule_atoms,
            template_atoms,
            left_cluster,
            right_cluster,
            left_anchor_idx,
            right_anchor_idx,
        )
    output_path = Path(aligned_mol_path).with_name("em_output.xyz")
    _write_xyz(
        output_path,
        em_atoms,
        comment=(
            f"EM assembled from {Path(aligned_mol_path).name} with template {Path(template_path).name}; {detail}"
        ),
    )
    return str(output_path)


def validate_em_structure(em_file_path: str | Path, template_path: str | Path) -> Tuple[bool, str]:
    em_atoms, _ = _read_xyz(em_file_path)
    template_atoms, _ = _read_xyz(template_path)
    left_template, right_template = _extract_au_clusters(template_atoms)
    n_left = len(left_template)
    n_right = len(right_template)
    if len(em_atoms) < n_left + n_right:
        return False, "EM file does not contain enough atoms to host both Au clusters"
    left_block = em_atoms[:n_left]
    right_block = em_atoms[-n_right:]
    if [atom["element"] for atom in left_block] != [atom["element"] for atom in left_template]:
        return False, "Left Au cluster ordering or elements do not match the template"
    if [atom["element"] for atom in right_block] != [atom["element"] for atom in right_template]:
        return False, "Right Au cluster ordering or elements do not match the template"
    middle_section = em_atoms[n_left : len(em_atoms) - n_right]
    if any(atom["element"].lower() == "au" for atom in middle_section):
        return False, "Au atoms detected outside the top and bottom cluster blocks"
    return True, ""


def _split_em_sections(em_atoms: Sequence[Atom], template_atoms: Sequence[Atom]) -> Tuple[List[Atom], List[Atom], List[Atom]]:
    left_cluster, right_cluster = _extract_au_clusters(template_atoms)
    n_left = len(left_cluster)
    n_right = len(right_cluster)
    if len(em_atoms) < n_left + n_right:
        raise ValueError("EM file does not contain enough atoms to host both Au clusters")
    left_block = list(em_atoms[:n_left])
    right_block = list(em_atoms[-n_right:])
    molecule_block = list(em_atoms[n_left : len(em_atoms) - n_right])
    return left_block, molecule_block, right_block


def _find_pyramid_apex(cluster: Sequence[Atom], side: str) -> Atom:
    if not cluster:
        raise ValueError("Cluster is empty, cannot determine apex")
    if side == "left":
        apex_idx = max(range(len(cluster)), key=lambda idx: cluster[idx]["coords"][2])
    elif side == "right":
        apex_idx = min(range(len(cluster)), key=lambda idx: cluster[idx]["coords"][2])
    else:
        raise ValueError("Side must be 'left' or 'right'")
    return cluster[apex_idx]


def _rotate_atoms_about_point(
    atoms: Sequence[Atom],
    point: Sequence[float],
    axis: Sequence[float],
    angle_rad: float,
) -> List[Atom]:
    rotation = _rotation_matrix_axis_angle(axis, angle_rad)
    rotated_atoms: List[Atom] = []
    for atom in atoms:
        shifted = [
            atom["coords"][0] - point[0],
            atom["coords"][1] - point[1],
            atom["coords"][2] - point[2],
        ]
        rotated = _matrix_vector_mul(rotation, shifted)
        rotated_atoms.append(
            {
                "element": atom["element"],
                "coords": [
                    rotated[0] + point[0],
                    rotated[1] + point[1],
                    rotated[2] + point[2],
                ],
            }
        )
    return rotated_atoms


def incline_em(
    em_file_path: str | Path,
    template_path: str | Path,
    left_anchor_idx: int,
    right_anchor_idx: int,
    angle_degrees: float,
    rotation_axis: Sequence[float] = (1.0, 0.0, 0.0),
    bond_R: float | None = None,
    allow_x_translation: bool = False,
) -> str:
    """
    Tilt only the molecule about the left anchor, then translate (not rotate) the right Au cluster to
    recover the desired Au–X bond length while forcing the right anchor–apex vector to be parallel to +Z.
    Left cluster stays fixed and unrotated.

    This routine is intended for the pyramid (4Au) template. It preserves file ordering: left Au block,
    tilted molecule block, right Au block.

    Args:
        em_file_path: EM xyz generated by assemble_em (anchors aligned to +Z).
        template_path: Template xyz (must be pyramid / 4Au).
        left_anchor_idx: 0-based index of the left anchor atom within the molecule block.
        right_anchor_idx: 0-based index of the right anchor atom within the molecule block.
        angle_degrees: Tilt angle to apply to the molecule.
        rotation_axis: Axis (length-3) to rotate around, passing through the left anchor (default +X).
        bond_R: Desired right Au–X bond length. If None, uses the pre-tilt bond length in em_file_path.
        allow_x_translation: Kept for backward compatibility; translation is now chosen to align the apex directly
            above the right anchor along +Z, which may include X translation if needed.
    Returns:
        Path to the inclined EM xyz file.
    """
    template_atoms, _ = _read_xyz(template_path)
    template_left, template_right = _extract_au_clusters(template_atoms)
    template_kind = _classify_template(template_left, template_right)
    if template_kind != "pyramid":
        raise ValueError("Inclined EM assembly currently supports only the pyramid (4Au) template")

    em_atoms, _ = _read_xyz(em_file_path)
    left_block, molecule_block, right_block = _split_em_sections(em_atoms, template_atoms)

    if not (0 <= left_anchor_idx < len(molecule_block)) or not (0 <= right_anchor_idx < len(molecule_block)):
        raise IndexError("Anchor indices must be within the molecule atom count")

    left_anchor = molecule_block[left_anchor_idx]["coords"]
    right_anchor = molecule_block[right_anchor_idx]["coords"]

    axis_norm = _norm(rotation_axis)
    if axis_norm == 0:
        raise ValueError("Rotation axis cannot be zero-length")
    axis_unit = [component / axis_norm for component in rotation_axis]

    angle_rad = math.radians(angle_degrees)
    rotated_molecule = _rotate_atoms_about_point(molecule_block, left_anchor, axis_unit, angle_rad)
    rotated_right_anchor = rotated_molecule[right_anchor_idx]["coords"]

    right_apex_atom = _find_pyramid_apex(right_block, side="right")
    right_apex = right_apex_atom["coords"]

    if bond_R is None:
        bond_R = _norm(
            [
                right_apex[0] - right_anchor[0],
                right_apex[1] - right_anchor[1],
                right_apex[2] - right_anchor[2],
            ]
        )

    if bond_R <= 0:
        raise ValueError("Desired right Au–X bond length must be positive")

    # Force right anchor–apex vector to be parallel to +Z: match x/y to anchor, set z = anchor_z + bond_R.
    target_apex = [
        rotated_right_anchor[0],
        rotated_right_anchor[1],
        rotated_right_anchor[2] + bond_R,
    ]
    translation = [
        target_apex[0] - right_apex[0],
        target_apex[1] - right_apex[1],
        target_apex[2] - right_apex[2],
    ]

    translated_right_block = [
        _translate_atom(atom, translation) for atom in right_block
    ]

    output_path = Path(em_file_path).with_name(f"{Path(em_file_path).stem}_inclined.xyz")
    comment = (
        f"Inclined EM: molecule rotated {angle_degrees:.3f} deg about axis "
        f"{axis_unit} at left anchor; right cluster translated to align apex above right anchor along +Z "
        f"with bond_R={bond_R:.3f}"
    )
    _write_xyz(
        output_path,
        list(left_block) + rotated_molecule + translated_right_block,
        comment=comment,
    )
    return str(output_path)
