"""
Utilities to build MST L3 full junction structures.

Exposes:
- align_molecule_to_z_axis(molecule_xyz, left_anchor_idx, right_anchor_idx)
- assemble_junction(aligned_mol_path, template_path, bond_L, bond_R, left_anchor_idx, right_anchor_idx)
- validate_junction_structure(junction_file_path, template_path)
- compute_em_z_length(junction_file_path, template_path, left_anchor_idx, right_anchor_idx)
"""

from __future__ import annotations

import math
from pathlib import Path
from typing import List, Sequence, Tuple

Atom = dict[str, Sequence[float]]


def _read_xyz(path: str | Path) -> Tuple[List[Atom], str]:
    path = Path(path)
    with path.open("r", encoding="utf-8") as handle:
        try:
            atom_count = int(handle.readline().strip())
        except ValueError as exc:
            raise ValueError(f"First line of {path} must be an integer atom count") from exc
        comment = handle.readline().rstrip("\n")
        atoms: List[Atom] = []
        for line in handle:
            parts = line.split()
            if len(parts) < 4:
                continue
            element = parts[0]
            try:
                coords = [float(parts[1]), float(parts[2]), float(parts[3])]
            except ValueError as exc:
                raise ValueError(f"Could not parse coordinates in {path}") from exc
            atoms.append({"element": element, "coords": coords})
        if len(atoms) != atom_count:
            raise ValueError(f"{path} reports {atom_count} atoms but {len(atoms)} coordinates were read")
    return atoms, comment


def _write_xyz(path: str | Path, atoms: Sequence[Atom], comment: str = "") -> None:
    path = Path(path)
    lines = [str(len(atoms)), comment or "Generated by MST junction builder"]
    for atom in atoms:
        x, y, z = atom["coords"]
        lines.append(f"{atom['element']:2s} {x:15.8f} {y:15.8f} {z:15.8f}")
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def _dot(a: Sequence[float], b: Sequence[float]) -> float:
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]


def _cross(a: Sequence[float], b: Sequence[float]) -> List[float]:
    return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0],
    ]


def _norm(vec: Sequence[float]) -> float:
    return math.sqrt(_dot(vec, vec))


def _normalize(vec: Sequence[float]) -> List[float]:
    length = _norm(vec)
    if length == 0:
        raise ValueError("Cannot normalize a zero-length vector")
    return [component / length for component in vec]


def _matrix_vector_mul(matrix: Sequence[Sequence[float]], vec: Sequence[float]) -> List[float]:
    return [
        matrix[0][0] * vec[0] + matrix[0][1] * vec[1] + matrix[0][2] * vec[2],
        matrix[1][0] * vec[0] + matrix[1][1] * vec[1] + matrix[1][2] * vec[2],
        matrix[2][0] * vec[0] + matrix[2][1] * vec[1] + matrix[2][2] * vec[2],
    ]


def _matrix_multiply(a: Sequence[Sequence[float]], b: Sequence[Sequence[float]]) -> List[List[float]]:
    product: List[List[float]] = []
    for row_idx in range(3):
        row: List[float] = []
        for col_idx in range(3):
            value = (
                a[row_idx][0] * b[0][col_idx]
                + a[row_idx][1] * b[1][col_idx]
                + a[row_idx][2] * b[2][col_idx]
            )
            row.append(value)
        product.append(row)
    return product


def _rotation_matrix_axis_angle(axis: Sequence[float], angle: float) -> List[List[float]]:
    axis_normalized = _normalize(axis)
    x, y, z = axis_normalized
    cos_theta = math.cos(angle)
    sin_theta = math.sin(angle)
    one_minus_cos = 1.0 - cos_theta
    return [
        [
            cos_theta + x * x * one_minus_cos,
            x * y * one_minus_cos - z * sin_theta,
            x * z * one_minus_cos + y * sin_theta,
        ],
        [
            y * x * one_minus_cos + z * sin_theta,
            cos_theta + y * y * one_minus_cos,
            y * z * one_minus_cos - x * sin_theta,
        ],
        [
            z * x * one_minus_cos - y * sin_theta,
            z * y * one_minus_cos + x * sin_theta,
            cos_theta + z * z * one_minus_cos,
        ],
    ]


def _rotation_matrix_from_vectors(v_from: Sequence[float], v_to: Sequence[float]) -> List[List[float]]:
    v1 = _normalize(v_from)
    v2 = _normalize(v_to)
    cross_prod = _cross(v1, v2)
    dot_prod = _dot(v1, v2)
    cross_norm = _norm(cross_prod)
    if cross_norm < 1e-12:
        if dot_prod > 0:
            return [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
        axis_guess = [1.0, 0.0, 0.0] if abs(v1[0]) < 0.9 else [0.0, 1.0, 0.0]
        return _rotation_matrix_axis_angle(axis_guess, math.pi)
    skew = [
        [0.0, -cross_prod[2], cross_prod[1]],
        [cross_prod[2], 0.0, -cross_prod[0]],
        [-cross_prod[1], cross_prod[0], 0.0],
    ]
    skew_sq = _matrix_multiply(skew, skew)
    scale = (1.0 - dot_prod) / (cross_norm ** 2)
    rotation: List[List[float]] = []
    for row_idx in range(3):
        row: List[float] = []
        for col_idx in range(3):
            value = (
                (1.0 if row_idx == col_idx else 0.0)
                + skew[row_idx][col_idx]
                + skew_sq[row_idx][col_idx] * scale
            )
            row.append(value)
        rotation.append(row)
    return rotation


def _translate_atom(atom: Atom, delta: Sequence[float]) -> Atom:
    return {
        "element": atom["element"],
        "coords": [
            atom["coords"][0] + delta[0],
            atom["coords"][1] + delta[1],
            atom["coords"][2] + delta[2],
        ],
    }


def _translate_atoms(atoms: Sequence[Atom], delta: Sequence[float]) -> List[Atom]:
    return [_translate_atom(atom, delta) for atom in atoms]


def _split_template_blocks(template_atoms: Sequence[Atom]) -> Tuple[List[Atom], List[Atom], List[Atom]]:
    left_block: List[Atom] = []
    idx = 0
    while idx < len(template_atoms) and template_atoms[idx]["element"].lower() == "au":
        left_block.append(template_atoms[idx])
        idx += 1
    right_block: List[Atom] = []
    idx_right = len(template_atoms) - 1
    while idx_right >= 0 and template_atoms[idx_right]["element"].lower() == "au":
        right_block.append(template_atoms[idx_right])
        idx_right -= 1
    right_block.reverse()
    if not left_block or not right_block:
        raise ValueError("Template must contain Au blocks at both the top and bottom of the file")
    molecule_block = list(template_atoms[len(left_block) : len(template_atoms) - len(right_block)])
    return left_block, molecule_block, right_block


def _template_anchor_sites(molecule_block: Sequence[Atom]) -> Tuple[Tuple[int, Atom], Tuple[int, Atom]]:
    heavy_atoms = [(idx, atom) for idx, atom in enumerate(molecule_block) if atom["element"].lower() != "h"]
    if len(heavy_atoms) < 2:
        raise ValueError("Template molecule must contain at least two non-H atoms to define anchors")
    left_idx, left_atom = min(heavy_atoms, key=lambda item: item[1]["coords"][2])
    right_idx, right_atom = max(heavy_atoms, key=lambda item: item[1]["coords"][2])
    if right_atom["coords"][2] <= left_atom["coords"][2]:
        raise ValueError("Template anchors must have increasing Z from left to right")
    return (left_idx, left_atom), (right_idx, right_atom)


def _nearest_au(anchor: Sequence[float], cluster: Sequence[Atom]) -> Atom:
    closest = None
    best_dist = None
    for atom in cluster:
        if atom["element"].lower() != "au":
            continue
        dx = atom["coords"][0] - anchor[0]
        dy = atom["coords"][1] - anchor[1]
        dz = atom["coords"][2] - anchor[2]
        dist = math.sqrt(dx * dx + dy * dy + dz * dz)
        if best_dist is None or dist < best_dist:
            best_dist = dist
            closest = atom
    if closest is None:
        raise ValueError("Cluster contains no Au atoms to measure contact distance")
    return closest


def align_molecule_to_z_axis(molecule_xyz: str | Path, left_anchor_idx: int, right_anchor_idx: int) -> str:
    atoms, _ = _read_xyz(molecule_xyz)
    if not (0 <= left_anchor_idx < len(atoms)) or not (0 <= right_anchor_idx < len(atoms)):
        raise IndexError("Anchor indices must be within the molecule atom count")
    left_atom = atoms[left_anchor_idx]
    right_atom = atoms[right_anchor_idx]
    anchor_vector = [
        right_atom["coords"][0] - left_atom["coords"][0],
        right_atom["coords"][1] - left_atom["coords"][1],
        right_atom["coords"][2] - left_atom["coords"][2],
    ]
    if _norm(anchor_vector) == 0:
        raise ValueError("Anchor atoms cannot occupy the same position")
    rotation = _rotation_matrix_from_vectors(anchor_vector, [0.0, 0.0, 1.0])
    aligned_atoms: List[Atom] = []
    for atom in atoms:
        shifted = [
            atom["coords"][0] - left_atom["coords"][0],
            atom["coords"][1] - left_atom["coords"][1],
            atom["coords"][2] - left_atom["coords"][2],
        ]
        rotated = _matrix_vector_mul(rotation, shifted)
        aligned_atoms.append({"element": atom["element"], "coords": rotated})
    aligned_path = Path(molecule_xyz).with_name("temp_aligned.xyz")
    _write_xyz(
        aligned_path,
        aligned_atoms,
        comment=(
            f"Aligned to +Z using anchors {left_anchor_idx} (left) and "
            f"{right_anchor_idx} (right); left anchor at origin"
        ),
    )
    return str(aligned_path)


def _solve_anchor_height(contact_point: Sequence[float], target_xy: Sequence[float], bond_length: float) -> float:
    dx = target_xy[0] - contact_point[0]
    dy = target_xy[1] - contact_point[1]
    residual = bond_length * bond_length - dx * dx - dy * dy
    if residual <= 0:
        raise ValueError("Requested bond length is too short for the lateral offset between anchor and contact site")
    return contact_point[2] + math.sqrt(residual)


def assemble_junction(
    aligned_mol_path: str | Path,
    template_path: str | Path,
    bond_L: float,
    bond_R: float,
    left_anchor_idx: int,
    right_anchor_idx: int,
) -> str:
    molecule_atoms, _ = _read_xyz(aligned_mol_path)
    template_atoms, _ = _read_xyz(template_path)
    if not (0 <= left_anchor_idx < len(molecule_atoms)) or not (0 <= right_anchor_idx < len(molecule_atoms)):
        raise IndexError("Anchor indices must be within the aligned molecule atom count")
    left_block, template_molecule, right_block = _split_template_blocks(template_atoms)
    (template_left_idx, template_left_anchor), (template_right_idx, template_right_anchor) = _template_anchor_sites(
        template_molecule
    )
    cluster_size = _cluster_size_from_template_name(template_path)
    if cluster_size == 1:
        left_contact = max(left_block, key=lambda atom: atom["coords"][2])
        right_contact = min(right_block, key=lambda atom: atom["coords"][2])
        target_xy = [left_contact["coords"][0], left_contact["coords"][1]]
    else:
        left_contact = _nearest_au(template_left_anchor["coords"], left_block)
        right_contact = _nearest_au(template_right_anchor["coords"], right_block)
        target_xy = [template_left_anchor["coords"][0], template_left_anchor["coords"][1]]
    left_anchor_coords = molecule_atoms[left_anchor_idx]["coords"]
    right_anchor_coords = molecule_atoms[right_anchor_idx]["coords"]
    if right_anchor_coords[2] <= left_anchor_coords[2]:
        raise ValueError("Right anchor must have a larger Z value than the left anchor after alignment")
    if _cluster_size_from_template_name(template_path) == 3:
        if molecule_atoms[left_anchor_idx]["element"].lower() != "s" or molecule_atoms[right_anchor_idx][
            "element"
        ].lower() != "s":
            raise ValueError("Trimer template requires both anchors to be S atoms")

    left_anchor_z = _solve_anchor_height(left_contact["coords"], target_xy, bond_L)
    translation = [
        target_xy[0] - left_anchor_coords[0],
        target_xy[1] - left_anchor_coords[1],
        left_anchor_z - left_anchor_coords[2],
    ]
    positioned_molecule = _translate_atoms(molecule_atoms, translation)

    positioned_right_anchor = positioned_molecule[right_anchor_idx]["coords"]
    dx_r = right_contact["coords"][0] - positioned_right_anchor[0]
    dy_r = right_contact["coords"][1] - positioned_right_anchor[1]
    residual_r = bond_R * bond_R - dx_r * dx_r - dy_r * dy_r
    if residual_r <= 0:
        raise ValueError("Requested right bond length is too short for the lateral offset to the right contact site")
    # Keep the right Au contact **beyond** the right anchor along +Z.
    target_contact_z = positioned_right_anchor[2] + math.sqrt(residual_r)
    right_translation_z = target_contact_z - right_contact["coords"][2]
    shifted_right_block = _translate_atoms(right_block, [0.0, 0.0, right_translation_z])

    output_path = Path(aligned_mol_path).with_name("junction_output.xyz")
    comment = (
        f"Junction assembled from {Path(aligned_mol_path).name} with template {Path(template_path).name}; "
        f"bond_L={bond_L:.3f} bond_R={bond_R:.3f}; "
        f"right electrode translated dz={right_translation_z:.4f}; "
        f"template anchors idx {template_left_idx}/{template_right_idx}"
    )
    _write_xyz(
        output_path,
        list(left_block) + positioned_molecule + shifted_right_block,
        comment=comment,
    )
    return str(output_path)


def validate_junction_structure(junction_file_path: str | Path, template_path: str | Path) -> Tuple[bool, str]:
    junction_atoms, _ = _read_xyz(junction_file_path)
    template_atoms, _ = _read_xyz(template_path)
    left_template, template_molecule, right_template = _split_template_blocks(template_atoms)
    n_left = len(left_template)
    n_right = len(right_template)
    if len(junction_atoms) < n_left + n_right:
        return False, "Junction file does not contain enough atoms to host both Au blocks"
    left_block = junction_atoms[:n_left]
    right_block = junction_atoms[-n_right:]
    if [atom["element"] for atom in left_block] != [atom["element"] for atom in left_template]:
        return False, "Left Au block ordering or elements do not match the template"
    if [atom["element"] for atom in right_block] != [atom["element"] for atom in right_template]:
        return False, "Right Au block ordering or elements do not match the template"
    middle_section = junction_atoms[n_left : len(junction_atoms) - n_right]
    if any(atom["element"].lower() == "au" for atom in middle_section):
        return False, "Au atoms detected outside the top and bottom electrode blocks"
    return True, ""


def compute_em_z_length(
    junction_file_path: str | Path,
    template_path: str | Path,
    left_anchor_idx: int,
    right_anchor_idx: int,
) -> float:
    junction_atoms, _ = _read_xyz(junction_file_path)
    template_atoms, _ = _read_xyz(template_path)
    left_template, _, right_template = _split_template_blocks(template_atoms)
    n_left = len(left_template)
    n_right = len(right_template)
    if len(junction_atoms) < n_left + n_right:
        raise ValueError("Junction file does not contain enough atoms to host both Au blocks")
    left_block = junction_atoms[:n_left]
    right_block = junction_atoms[-n_right:]
    molecule_block = junction_atoms[n_left : len(junction_atoms) - n_right]
    if not (0 <= left_anchor_idx < len(molecule_block)) or not (0 <= right_anchor_idx < len(molecule_block)):
        raise IndexError("Anchor indices must be within the molecule block of the assembled junction")
    left_anchor = molecule_block[left_anchor_idx]["coords"]
    right_anchor = molecule_block[right_anchor_idx]["coords"]

    cluster_size = _cluster_size_from_template_name(template_path)

    def pick_cluster(block: Sequence[Atom], anchor: Sequence[float]) -> List[Atom]:
        au_atoms = [(idx, atom) for idx, atom in enumerate(block) if atom["element"].lower() == "au"]
        if len(au_atoms) < cluster_size:
            raise ValueError("Au block does not contain enough atoms to extract the small cluster")
        sorted_atoms = sorted(
            au_atoms,
            key=lambda item: math.dist(anchor, item[1]["coords"]),
        )
        return [item[1] for item in sorted_atoms[:cluster_size]]

    left_cluster = pick_cluster(left_block, left_anchor)
    right_cluster = pick_cluster(right_block, right_anchor)

    z_values = [atom["coords"][2] for atom in left_cluster]
    z_values.extend(atom["coords"][2] for atom in molecule_block)
    z_values.extend(atom["coords"][2] for atom in right_cluster)
    return max(z_values) - min(z_values)


def _cluster_size_from_template_name(template_path: str | Path) -> int:
    name = Path(template_path).name.lower()
    if "pyramid" in name:
        return 4
    if "trimer" in name:
        return 3
    if "adatom" in name:
        return 1
    raise ValueError("Unable to infer cluster size from template name; expected adatom/trimer/pyramid in filename")
